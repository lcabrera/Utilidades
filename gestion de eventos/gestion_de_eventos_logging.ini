[loggers]
# En  primer  lugar, se  exponen  varios  métodos  para el  código  de
# aplicación para que las aplicaciones pueden registrar los mensajes en
# tiempo de  ejecución. En  segundo lugar,  los objetos  registrador de
# determinar qué mensajes de registro para actuar en base a la gravedad
# (la instalación predeterminada de filtrado)  o los objetos de filtro.
# En  tercer lugar,  los  objetos pasan  a lo  largo  de registrador  de
# mensajes  de registro  correspondientes a  todos los  controladores de
# registro de interesados.
#
# First,  they  expose  several  methods to  application  code  so  that
# applications  can  log messages  at  runtime.  Second, logger  objects
# determine  which log  messages to  act upon  based upon  severity (the
# default filtering  facility) or filter objects.  Third, logger objects
# pass along relevant log messages to all interested log handlers.
keys=root, nivel1, nivel2

[handlers]
#  Logger puede agregar cero o más  objetos de controlador a sí mismos
# con  un  addHandler  ()  método.  En un  escenario  de  ejemplo,  una
# aplicación puede enviar  todos los mensajes de registro  a un archivo
# de registro, todos  los mensajes de registro de error  o superior a la
# salida estándar, y todos los mensajes de crítica a una dirección de
# correo  electrónico. Este  escenario requiere  de tres  controladores
# individuales donde cada controlador  es responsable de enviar mensajes
# de una gravedad específica de un lugar específico.
#
# Logger objects can add zero or more handler objects to themselves with
# an addHandler()  method. As  an example  scenario, an  application may
# want to send all log messages to a log file, all log messages of error
# or higher to stdout, and all messages of critical to an email address.
# This scenario requires three individual handlers where each handler is
# responsible for sending messages of  a specific severity to a specific
# location.
keys=file, syslog

[formatters]
# objetos formateador configurar el orden final, estructura y contenido
# del mensaje de registro. A diferencia de la clase logging.Handler
# base, código de la aplicación puede crear una instancia del
# formateador clases, aunque es probable que podía derivar el
# formateador si su aplicación necesita un comportamiento especial.
#
# Formatter objects configure the final order, structure, and contents
# of the log message. Unlike the base logging.Handler class, application
# code may instantiate formatter classes, although you could likely
# subclass the formatter if your application needs special behavior.
keys=short,medium,long

[logger_root]
handlers=file
level=DEBUG

[logger_nivel1]
level=DEBUG
qualname=log1
handlers=syslog

[logger_nivel2]
level=DEBUG
qualname=log2
handlers=file

#[logger_area11]
#level=INFO
#qualname=log02.log03
#handlers=socket

#[logger_area111]
#level=WARN
#propagate=0
#qualname=log02.log03.log04
#handlers=datagram

#[logger_area1111]
#level=ERROR
#qualname=log02.log03.log04.log05
#handlers=syslog

#[logger_area11111]
#level=CRITICAL
#qualname=log02.log03.log04.log05.log06
#handlers=NT

#[logger_area111111]
#level=WARN
#qualname=log02.log03.log04.log05.log06.log07
#handlers=SMTP

#[handler_console]
#class=StreamHandler
#formatter=medium
#stream=sys.stdout
#args=(sys.stdout,)

[handler_file]
class=FileHandler
level=DEBUG
formatter=long
args=('gestion_de_eventos_logging.log', 'w')

#[handler_socket]
#class=handlers.SocketHandler
#level=INFO
#formatter=medium
#args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)

#[handler_datagram]
#class=handlers.DatagramHandler
#level=WARN
#formatter=medium
#args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)

[handler_syslog]
class=handlers.SysLogHandler
level=DEBUG
formatter=short
args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)

#[handler_NT]
#class=handlers.NTEventLogHandler
#level=CRITICAL
#formatter=medium
#args=('Python Application', '', 'Application')

#[handler_SMTP]
#class=handlers.SMTPHandler
#level=WARN
#formatter=long
#args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')

[formatter_short]
format=%(message)s

[formatter_medium]
format=%(asctime)s %(levelname)s %(message)s
datefmt=%Y%d%m %H:%M

[formatter_long]
#format=%(asctime)s %(pathname)s(%(lineno)d): %(levelname)s %(message)s
format=%(asctime)s %(name)s %(pathname)s(%(lineno)d) (%(threadName)s - %(process)s): %(levelname)s %(message)s
datefmt=%Y%d%m %H:%M

# Formatos:
#%(name)subjectName of the logger (logging channel).
#%(levelno)subjectNameNumeric logging level for the message (DEBUG,%INFO, WARNING, ERROR, CRITICAL).
#%(levelname)subjectNameNumericText logging level for the message ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL').
#%(pathname)subjectNameNumericTextFull pathname of the source file where the logging call was issued (if available).
#%(filename)sourceFilename portion of pathname.
#%(module)sourceFilenameModule (name portion of filename).
#%(funcName)sourceFilenameModuleName of function containing the logging call.
#%(lineno)debugSource line number where the logging call was issued (if available).
#%(created)functionTime when the LogRecord was created (as returned by time.time()).
#%(relativeCreated)debugSourceTime in milliseconds when the LogRecord %was created, relative to the time the logging module was loaded.
#%(asctime)sourceFilenameModuleNameHuman-readable time when the LogRecord was created. By default this is of the form “2003-07-08 16:49:45,896” (the numbers after the comma are millisecond portion of the time).
#%(msecs)defaultMillisecond portion of the time when the LogRecord was created.
#%(thread)defaultMillisecondThread ID (if available).
#%(threadName)sourceFilenameModuleNameHumanThread name (if available).
#%(process)defaultMillisecondThreadProcess ID (if available).
#%(message)sourceFilenameModuleNameHumanThreadThe logged message, computed as msg % args.

